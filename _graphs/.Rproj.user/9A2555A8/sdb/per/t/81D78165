{
    "collab_server" : "",
    "contents" : "\"._a2r_hclu\"       <- NULL # to receive an hclust object when \n# A2Rplot.hclust is called\n\n\"._a2r_counter\"       <- NA # a counter used in A2Rplot.hclust\n\"._a2r_height_cut\"    <- NA\n\n\"._a2r_envir\"         <- NA\n\"._a2r_group\"         <- NA\n\n\n#===============================================================================\n\"A2Rplot\" <- function(x,...){\n  UseMethod(\"A2Rplot\")\n}\n#===============================================================================\n\"A2Rplot.default\" <- function(x,...){\n  plot(x,...)\n}\n#===============================================================================\n\"A2Rplot.hclust\" <- function(\n  x ,             # an hclust object to draw\n  k        = 2,   # the number of groups\n  col.up   = \"black\",\n  col.down = rainbow(k),\n  lty.up   = 2,\n  lty.down = 1,\n  lwd.up   = 1,\n  lwd.down = 2,\n  type     = c(\"rectangle\",\"triangle\"),\n  knot.pos = c(\"mean\",\"bary\",\"left\",\"right\",\"random\"),\n  criteria,\n  fact.sup,\n  show.labels=TRUE,\n  only.tree=FALSE,\n  main     = paste(\"Colored Dendrogram (\",k,\" groups)\"),\n  boxes    = TRUE,\n  members,\n  ...\n){\n  \n  if(missing(members)) members <- NULL\n  opar <- par(no.readonly=TRUE)\n  knot.pos <- match.arg(knot.pos)\n  type     <- match.arg(type)\n  # tests\n  if(k<2) \n    stop(\"k must be at least 2\")  \n  \n  ._a2r_counter    <<- 0\n  ._a2r_hclu       <<- x\n  \n  ._a2r_envir      <<- environment()\n  nn <- length(x$order) - 1\n  \n  ._a2r_height_cut <<- mean(x$height[nn-k+1:2])\n  ._a2r_group      <<- 0\n  \n  n.indiv   <- length(x$order)\n  groups.o  <- cutree.order(x, k=k)[x$order]\n  \n  bottom <- if(is.null(members)) 0 else x$height[nn] * -.2 \n  \n  if(only.tree){\n    if(is.null(members)) plot(0,type=\"n\",xlim=c(0.5,n.indiv+.5), ylim=c(bottom,x$height[nn]), xaxs=\"i\", axes=FALSE, xlab=\"\",ylab=\"\") \n    else                 plot(0,type=\"n\",xlim=c(0.5,sum(members)+.5), ylim=c(bottom,x$height[nn]), xaxs=\"i\", axes=FALSE, xlab=\"\",ylab=\"\")\n    #call to the ** recursive function ** .rec.hclust\n    .rec.hclust(nn, col=col.up, lty=lty.up, lwd=lwd.up)\n    \n    if(boxes){\n      axis(2)\n      box()\n    }\n    return(NULL)\n  }\n  \n  # prepare the layout\n  matlayout <- matrix(c(2,4,6,1,3,5), nc=2, nr=3)\n  widths    <- c(1,9)\n  heights   <- c(8,1,1)\n  if(!show.labels){\n    matlayout <- matrix(c(2,4,1,3), nc=2, nr=2)\n    widths    <- c(1,9)\n    heights   <- c(9,1)\n  }\n  if(!missing(fact.sup) ) {\n    heights   <- c(8,1,1)\n  }\n  if(missing(criteria) & missing(fact.sup)){\n    matlayout <- matrix(c(2,4,1,3), nc=2, nr=2)\n    widths    <- c(1,9)\n    heights   <- c(9,1)\n    \n  }\n  layout(matlayout, width=widths, height=heights)\n  \n  \n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ The tree (1)\n  par(mar=c(0,0,3,4))\n  if(is.null(members)) plot(0,type=\"n\",xlim=c(0.5,n.indiv+.5), ylim=c(bottom,x$height[nn]), xaxs=\"i\", axes=FALSE, xlab=\"\",ylab=\"\") \n  else plot(0,type=\"n\",xlim=c(0.5,sum(members)+.5), ylim=c(bottom,x$height[nn]), xaxs=\"i\", axes=FALSE, xlab=\"\",ylab=\"\") \n  #call to the ** recursive function ** .rec.hclust\n  .rec.hclust(nn, col=col.up, lty=lty.up, lwd=lwd.up)\n  title(main)\n  if(boxes){\n    box()\n    axis(4)\n  }\n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Criteria (2)\n  if(!missing(criteria)){\n    par(mar=c(0,0,3,0))\n    plot(0,\n         type=\"n\",\n         xlim=range(criteria), \n         ylim=c(0,x$height[nn]), \n         axes=FALSE, \n         xlab=\"\",\n         ylab=\"\")\n    par(las=2)\n    n.crit <- length(criteria)\n    heights.cut <- ( tail(x$height,n.crit) + \n                       tail(x$height,n.crit+1)[-(n.crit+1)] ) / 2\n    heights.cut <- rev(heights.cut)\n    \n    points(criteria   , heights.cut   , pch=21, bg=\"red\", type=\"o\")\n    points(criteria[k-1], heights.cut[k-1], pch=21, cex=2, bg=\"blue\", xpd=NA)\n    if(boxes){\n      axis(3)\n      box()\n    }\n  }\n  else{\n    par(mar=c(0,0,3,0))\n    plot(0,\n         type=\"n\",\n         xlim=c(0,1), \n         ylim=c(0,1), \n         axes=FALSE, \n         xlab=\"\",\n         ylab=\"\")\n  }\n  \n  if(show.labels){\n    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Name of the observations (3)\n    par(mar=c(0,0,0,4))\n    par(srt=90)\n    obs.labels <- toupper(substr(x$labels[x$order],1,6))\n    if(is.null(members)) {\n      plot(0,type=\"n\",xlim=c(0.5,n.indiv+.5), ylim=c(0,1), xaxs=\"i\", axes=FALSE, xlab=\"\",ylab=\"\") \n      text(1:n.indiv            , 0, obs.labels, pos=4, col=col.down[groups.o])\n    }\n    else{\n      plot(0,type=\"n\",xlim=c(0.5,sum(members)+.5), ylim=c(0,1), xaxs=\"i\", axes=FALSE, xlab=\"\",ylab=\"\") \n      xo <-   members[x$order]\n      text(cumsum(xo)-xo/2, 0, obs.labels, pos=4, col=col.down[groups.o])\n    }\n    par(srt=0)\n    if(boxes){\n      box()\n    }\n    \n    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Labels (4)\n    par(mar=c(0,0,0,0))\n    plot(0,type=\"n\",xlim=c(0,1), ylim=c(0,1), xaxs=\"i\", axes=FALSE, xlab=\"\",ylab=\"\") \n    text(.5,.5,\"Labels\")\n    if(boxes){\n      box()\n    }\n    \n  }\n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Quali (5,6)\n  if(!missing(fact.sup)){\n    quali  <- as.factor(fact.sup)[x$order]\n    quanti <- as.numeric(quali)\n    \n    par(mar=c(1,0,0,4))\n    n.levels <- length(levels(quali))\n    plot(0,type=\"n\",\n         xlim=c(0.5,n.indiv+.5), \n         ylim=c(0,n.levels), \n         xaxs=\"i\", yaxs=\"i\",axes=FALSE, xlab=\"\",ylab=\"\") \n    \n    rect(xleft    = (1:n.indiv)-.5,\n         xright   = (1:n.indiv)+.5,\n         ybottom  = quanti-1, \n         ytop     = quanti,\n         col      = col.down[groups.o])\n    par(las=1)\n    axis(4, (1:n.levels)-.5,levels(quali), tick=FALSE)\n    \n    if(boxes){\n      box()\n    }\n    \n    \n    par(mar=c(1,0,0,0))\n    plot(0,type=\"n\",xlim=c(0,1), ylim=c(0,1), xaxs=\"i\", axes=FALSE, xlab=\"\",ylab=\"\") \n    text(.5,.5,deparse(substitute(fact.sup)))\n    if(boxes){\n      box()\n    }\n  }\n  \n  \n#  par(opar) # reset parameter\n}\n\n#===============================================================================\n\n\".rec.hclust\" <- function(\n  index, # index of the current tree to draw\n  lwd = 1,\n  lty = 1,\n  col = \"black\"){\n  \n  members <- get('members', envir= ._a2r_envir) \n  bottom  <- get('bottom',  envir= ._a2r_envir) \n  if(index<0){ # it is a leaf\n    if(is.null(members)){\n      ._a2r_counter <<- ._a2r_counter + 1\n      return(list( x = ._a2r_counter,\n                   n = 1))       \n    }\n    else{\n      cc <- ._a2r_counter\n      mm <- members[-index]\n      polygon(x  = c(cc, cc+mm/2, cc+mm),\n              y  = c(bottom, 0, bottom),\n              col= col, \n              border = col, \n              lwd=lwd)\n      ._a2r_counter <<- ._a2r_counter + mm\n      return(list(x = cc+mm/2,\n                  n = mm))\n    }\n  }\n  \n  h.m   <- ._a2r_hclu$height[index]\n  \n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~ do left\n  index.l  <- ._a2r_hclu$merge[index,1]\n  \n  h.l <- if(index.l<0) 0 else ._a2r_hclu$height[index.l]\n  if(h.l<._a2r_height_cut & h.m > ._a2r_height_cut){\n    ._a2r_group <<- ._a2r_group + 1\n    col.l <- get(\"col.down\",envir=._a2r_envir)[._a2r_group]\n    lwd.l <- get(\"lwd.down\",envir=._a2r_envir)\n    lty.l <- get(\"lty.down\",envir=._a2r_envir)\n  }\n  else{\n    col.l <- col\n    lwd.l <- lwd\n    lty.l <- lty\n  }\n  out.l   <- .rec.hclust(index.l, col=col.l, lty=lty.l, lwd=lwd.l)\n  x.l     <- out.l$x\n  n.l     <- out.l$n\n  \n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ do right\n  index.r  <- ._a2r_hclu$merge[index,2]\n  h.r <- if(index.r<0) 0 else ._a2r_hclu$height[index.r]\n  if(h.r<._a2r_height_cut & h.m > ._a2r_height_cut){\n    ._a2r_group <<- ._a2r_group + 1\n    col.r <- get(\"col.down\",envir=._a2r_envir)[._a2r_group]\n    lwd.r <- get(\"lwd.down\",envir=._a2r_envir)\n    lty.r <- get(\"lty.down\",envir=._a2r_envir)\n  }\n  else{\n    col.r <- col\n    lwd.r <- lwd\n    lty.r <- lty\n  }\n  out.r   <- .rec.hclust(index.r, col=col.r, lty=lty.r, lwd=lwd.r)\n  x.r     <- out.r$x\n  n.r     <- out.r$n\n  \n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ draw what you have to draw\n  \n  type <- get(\"type\",envir=._a2r_envir)\n  x.m  <- (x.r + x.l) / 2  \n  n    <- n.r + n.l\n  x.b  <- (n.r * x.r + n.l * x.l) / n\n  \n  \n  knot.pos <- get(\"knot.pos\",envir=._a2r_envir) \n  \n  x <- switch(knot.pos,\n              mean = x.m,\n              left = x.l,\n              right= x.r,\n              random = x.l + runif(1)*(x.r-x.l),\n              bary   = x.b)\n  \n  \n  \n  if(type==\"rectangle\"){\n    segments(x0  = c(x.l, x.l, x.r),\n             x1  = c(x.l, x.r, x.r),\n             y0  = c(h.l, h.m, h.r),\n             y1  = c(h.m, h.m, h.m),\n             col = col,\n             lty = lty,\n             lwd = lwd)\n  }\n  if(type ==\"triangle\"){\n    segments(x0  = c(x.l, x.r),\n             x1  = c(x  , x),\n             y0  = c(h.l, h.r),\n             y1  = c(h.m, h.m),\n             col = col,\n             lty = lty,\n             lwd = lwd)\n  }\n  \n  \n  list(x=x,n=n)\n}\n#===============================================================================\n\"cutree.order\" <- function(hclu, k=NULL, h=NULL){\n  \n  coupe <- cutree(hclu,k=k, h=h)\n  \n  coupe.or <- coupe[hclu$order]\n  coupe.out<- rep(NA,length(coupe))\n  j <-  1 #\n  k <-  coupe.or[1]\n  for(i in 1:length(coupe)){\n    if(coupe.or[i]==k) next\n    else{\n      coupe.out[which(coupe==k)] <- j\n      j <- j + 1\n      k <- coupe.or[i]\n    }\n  }\n  coupe.out[is.na(coupe.out)] <- j\n  names(coupe.out) <- names(coupe)\n  coupe.out\n}\n#===============================================================================\n",
    "created" : 1512135436669.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1822879911",
    "id" : "81D78165",
    "lastKnownWriteTime" : 1429775476,
    "last_content_update" : 1429775476,
    "path" : "Z:/_cam/_codes/_r/_graphs/A2R_dendrogram.R",
    "project_path" : "A2R_dendrogram.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}